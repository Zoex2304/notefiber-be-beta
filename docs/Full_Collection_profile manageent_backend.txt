============================================================
BULKCOLLECT FULL EXPORT
Date: 2025-12-24 15:34:46
Total Files: 11
Total Size: 0.06 MB
============================================================

>>> FILE: main.go
package main

import (
	"context"
	"log"

	"ai-notetaking-be/internal/bootstrap"
	"ai-notetaking-be/internal/config"
	"ai-notetaking-be/internal/server"
	"ai-notetaking-be/internal/tracer"
	"ai-notetaking-be/pkg/database"
)

func main() {
	// 0. Initialize Tracer (for request flow tracing)
	shutdownTracer := tracer.InitTracer()
	defer shutdownTracer(context.Background())

	// 1. Load Configuration
	cfg := config.Load()

	// 2. Initialize Database
	gormDB, err := database.NewGormDBFromDSN(cfg.Database.Connection)
	if err != nil {
		log.Panicf("Unable to connect to GORM DB: %v", err)
	}

	// 3. Bootstrap Dependencies (Container)
	container := bootstrap.NewContainer(gormDB, cfg)

	// 4. Start Background Services
	// Note: In a larger app, we might use an errgroup or supervisor here
	go func() {
		log.Println("Background: Starting Consumer Service...")
		if err := container.ConsumerService.Consume(context.Background()); err != nil {
			log.Printf("Background Consumer Error: %v", err)
		}
	}()

	// 5. Initialize Server
	srv := server.New(cfg, container)

	// 6. Run Server
	log.Fatal(srv.Run())
}



>>> FILE: D:\notetaker\notefiber-BE\internal\bootstrap\container.go
package bootstrap

import (
	"ai-notetaking-be/internal/config"
	"ai-notetaking-be/internal/controller"
	"ai-notetaking-be/internal/pkg/logger"
	"ai-notetaking-be/internal/pkg/mailer"
	"ai-notetaking-be/internal/repository/unitofwork"
	"ai-notetaking-be/internal/service"

	"github.com/ThreeDotsLabs/watermill"
	"github.com/ThreeDotsLabs/watermill/pubsub/gochannel"
	"gorm.io/gorm"
)

type Container struct {
	// Controllers
	NotebookController controller.INotebookController
	NoteController     controller.INoteController
	UserController     controller.IUserController
	AuthController     controller.IAuthController
	OAuthController    controller.IOAuthController
	AdminController    controller.IAdminController
	PaymentController  controller.IPaymentController
	ChatbotController  controller.IChatbotController
	LocationController controller.ILocationController
	PlanController     controller.PlanController

	// Background Services (Exposed for main.go to run)
	ConsumerService service.IConsumerService
}

func NewContainer(db *gorm.DB, cfg *config.Config) *Container {
	// 1. Core Facades
	// 1. Core Facades
	uowFactory := unitofwork.NewRepositoryFactory(db)
	sysLogger := logger.NewZapLogger(cfg.App.LogFilePath, cfg.App.Environment == "production")

	emailService := mailer.NewEmailService(
		cfg.SMTP.Host,
		cfg.SMTP.Port,
		cfg.SMTP.Email,
		cfg.SMTP.Password,
		cfg.SMTP.SenderName,
	)

	// 2. Event Bus
	watermillLogger := watermill.NewStdLogger(false, false)
	pubSub := gochannel.NewGoChannel(
		gochannel.Config{},
		watermillLogger,
	)

	// 3. Services
	publisherService := service.NewPublisherService(cfg.Keys.ExampleTopic, pubSub)
	consumerService := service.NewConsumerService(pubSub, cfg.Keys.ExampleTopic, uowFactory)

	userService := service.NewUserService(uowFactory)
	authService := service.NewAuthService(uowFactory, emailService)
	oauthService := service.NewOAuthService(uowFactory)

	notebookService := service.NewNotebookService(uowFactory, publisherService)
	noteService := service.NewNoteService(uowFactory, publisherService)

	chatbotService := service.NewChatbotService(uowFactory)
	paymentService := service.NewPaymentService(uowFactory)
	adminService := service.NewAdminService(uowFactory, sysLogger)

	locationService := service.NewLocationService(cfg.Keys.Geoapify, cfg.Keys.Binderbyte)
	planService := service.NewPlanService(uowFactory)

	// 4. Controllers
	// Note: We return the container with public fields for the server to register
	return &Container{
		NotebookController: controller.NewNotebookController(notebookService),
		NoteController:     controller.NewNoteController(noteService),
		UserController:     controller.NewUserController(userService),
		AuthController:     controller.NewAuthController(authService),
		OAuthController:    controller.NewOAuthController(oauthService),
		AdminController:    controller.NewAdminController(adminService, authService),
		PaymentController:  controller.NewPaymentController(paymentService),
		ChatbotController:  controller.NewChatbotController(chatbotService),
		LocationController: controller.NewLocationController(locationService),
		PlanController:     controller.NewPlanController(planService),

		ConsumerService: consumerService,
	}
}



>>> FILE: D:\notetaker\notefiber-BE\internal\server\server.go
package server

import (
	"log"

	"ai-notetaking-be/internal/bootstrap"
	"ai-notetaking-be/internal/config"
	"ai-notetaking-be/internal/pkg/serverutils"

	"github.com/gofiber/contrib/otelfiber"
	"github.com/gofiber/fiber/v2"
	"github.com/gofiber/fiber/v2/middleware/cors"
)

type Server struct {
	app       *fiber.App
	cfg       *config.Config
	container *bootstrap.Container
}

func New(cfg *config.Config, container *bootstrap.Container) *Server {
	// Initialize Fiber App
	app := fiber.New(fiber.Config{
		BodyLimit: 10 * 1024 * 1024, // 10MB
		// Add ErrorHandler here if preferred inside config, but middleware below works too
	})

	// Middleware
	app.Use(cors.New(cors.Config{
		AllowOrigins:     cfg.App.CorsAllowedOrigins,
		AllowCredentials: true,
		AllowHeaders:     "Origin, Content-Type, Accept, Authorization",
		AllowMethods:     "GET, POST, PUT, PATCH, DELETE, OPTIONS",
		ExposeHeaders:    "Content-Length, Content-Type, Authorization",
	}))

	// OpenTelemetry tracing middleware (traces all HTTP requests)
	app.Use(otelfiber.Middleware())

	app.Use(serverutils.ErrorHandlerMiddleware())

	// Static
	app.Static("/uploads", "./uploads")

	// Routes
	registerRoutes(app, container)

	return &Server{
		app:       app,
		cfg:       cfg,
		container: container,
	}
}

func (s *Server) GetApp() *fiber.App {
	return s.app
}

func (s *Server) Run() error {
	log.Printf("âœ… Server is running on http://localhost:%s", s.cfg.App.Port)
	return s.app.Listen(":" + s.cfg.App.Port)
}

func registerRoutes(app *fiber.App, c *bootstrap.Container) {
	api := app.Group("/api")

	c.AuthController.RegisterRoutes(api)
	c.UserController.RegisterRoutes(api)
	c.OAuthController.RegisterRoutes(api)

	c.NotebookController.RegisterRoutes(api)
	c.NoteController.RegisterRoutes(api)
	c.ChatbotController.RegisterRoutes(api)

	c.PaymentController.RegisterRoutes(api)
	c.AdminController.RegisterRoutes(api)
	c.LocationController.RegisterRoutes(api)
	c.PlanController.RegisterRoutes(api, serverutils.JwtMiddleware)
}



>>> FILE: D:\notetaker\notefiber-BE\internal\controller\user_controller.go
// FILE: internal/controller/user_controller.go
package controller

import (
	"ai-notetaking-be/internal/dto"
	"ai-notetaking-be/internal/pkg/serverutils"
	"ai-notetaking-be/internal/service"

	"github.com/gofiber/fiber/v2"
	"github.com/google/uuid"
)

type IUserController interface {
	RegisterRoutes(r fiber.Router)
	GetProfile(ctx *fiber.Ctx) error
	UpdateProfile(ctx *fiber.Ctx) error
	DeleteAccount(ctx *fiber.Ctx) error
	UploadAvatar(ctx *fiber.Ctx) error
	RequestRefund(ctx *fiber.Ctx) error
}

type userController struct {
	service service.IUserService
}

func NewUserController(service service.IUserService) IUserController {
	return &userController{service: service}
}

func (c *userController) RegisterRoutes(r fiber.Router) {
	h := r.Group("/user")
	h.Use(serverutils.JwtMiddleware) // Ensure this middleware is available or reuse the one from payment controller logic
	h.Get("/profile", c.GetProfile)
	h.Put("/profile", c.UpdateProfile)
	h.Delete("/account", c.DeleteAccount)
	h.Post("/avatar", c.UploadAvatar)
	h.Post("/refund/request", c.RequestRefund) // New: User refund request
}

func (c *userController) GetProfile(ctx *fiber.Ctx) error {
	userIdStr := ctx.Locals("user_id").(string)
	userId, _ := uuid.Parse(userIdStr)

	res, err := c.service.GetProfile(ctx.Context(), userId)
	if err != nil {
		return ctx.Status(fiber.StatusInternalServerError).JSON(serverutils.ErrorResponse(500, err.Error()))
	}
	return ctx.JSON(serverutils.SuccessResponse("User profile", res))
}

func (c *userController) UpdateProfile(ctx *fiber.Ctx) error {
	userIdStr := ctx.Locals("user_id").(string)
	userId, _ := uuid.Parse(userIdStr)

	var req dto.UpdateProfileRequest
	if err := ctx.BodyParser(&req); err != nil {
		return err
	}
	if err := serverutils.ValidateRequest(req); err != nil {
		return err
	}

	err := c.service.UpdateProfile(ctx.Context(), userId, &req)
	if err != nil {
		return ctx.Status(fiber.StatusInternalServerError).JSON(serverutils.ErrorResponse(500, err.Error()))
	}
	return ctx.JSON(serverutils.SuccessResponse[any]("Profile updated", nil))
}

func (c *userController) DeleteAccount(ctx *fiber.Ctx) error {
	userIdStr := ctx.Locals("user_id").(string)
	userId, _ := uuid.Parse(userIdStr)

	err := c.service.DeleteAccount(ctx.Context(), userId)
	if err != nil {
		return ctx.Status(fiber.StatusInternalServerError).JSON(serverutils.ErrorResponse(500, err.Error()))
	}
	return ctx.JSON(serverutils.SuccessResponse[any]("Account deleted", nil))
}

func (c *userController) UploadAvatar(ctx *fiber.Ctx) error {
	userIdStr := ctx.Locals("user_id").(string)
	userId, _ := uuid.Parse(userIdStr)

	// Get file from request
	file, err := ctx.FormFile("avatar")
	if err != nil {
		return ctx.Status(fiber.StatusBadRequest).JSON(serverutils.ErrorResponse(400, "Image file is required"))
	}

	url, err := c.service.UploadAvatar(ctx.Context(), userId, file)
	if err != nil {
		return ctx.Status(fiber.StatusInternalServerError).JSON(serverutils.ErrorResponse(500, err.Error()))
	}

	return ctx.JSON(serverutils.SuccessResponse("Avatar uploaded successfully", map[string]string{
		"avatar_url": url,
	}))
}

// RequestRefund handles user refund request
func (c *userController) RequestRefund(ctx *fiber.Ctx) error {
	userIdStr := ctx.Locals("user_id").(string)
	userId, _ := uuid.Parse(userIdStr)

	var req dto.UserRefundRequest
	if err := ctx.BodyParser(&req); err != nil {
		return ctx.Status(fiber.StatusBadRequest).JSON(serverutils.ErrorResponse(400, "Invalid request body"))
	}

	if req.SubscriptionId == uuid.Nil {
		return ctx.Status(fiber.StatusBadRequest).JSON(serverutils.ErrorResponse(400, "subscription_id is required"))
	}
	if req.Reason == "" || len(req.Reason) < 10 {
		return ctx.Status(fiber.StatusBadRequest).JSON(serverutils.ErrorResponse(400, "reason must be at least 10 characters"))
	}

	res, err := c.service.RequestRefund(ctx.Context(), userId, req)
	if err != nil {
		// Handle specific errors
		errMsg := err.Error()
		if errMsg == "subscription not found" {
			return ctx.Status(fiber.StatusNotFound).JSON(serverutils.ErrorResponse(404, errMsg))
		}
		if errMsg == "refund already requested for this subscription" ||
			errMsg == "subscription is not active" ||
			errMsg == "subscription is not eligible for refund" {
			return ctx.Status(fiber.StatusBadRequest).JSON(serverutils.ErrorResponse(400, errMsg))
		}
		return ctx.Status(fiber.StatusInternalServerError).JSON(serverutils.ErrorResponse(500, err.Error()))
	}

	return ctx.JSON(serverutils.SuccessResponse("Refund request submitted", res))
}



>>> FILE: D:\notetaker\notefiber-BE\internal\dto\user_dto.go
// FILE: internal/dto/user_dto.go
package dto

import (
	"time"

	"github.com/google/uuid"
)

type UserProfileResponse struct {
	Id           uuid.UUID `json:"id"`
	Email        string    `json:"email"`
	FullName     string    `json:"full_name"`
	Role         string    `json:"role"`
	Status       string    `json:"status"`
	AvatarURL    string    `json:"avatar_url,omitempty"` // âœ… From code lama: Avatar URL (omit if empty)
	AiDailyUsage int       `json:"ai_daily_usage"`
	CreatedAt    time.Time `json:"created_at"`
}

type UpdateProfileRequest struct {
	FullName string `json:"full_name" validate:"required,min=3"`
	Email    string `json:"email" validate:"omitempty,email"` // âœ… From code lama: Added optional email update
}

// âœ… NEW: Feature flags structure
type SubscriptionFeatures struct {
	AiChat              bool `json:"ai_chat"`
	SemanticSearch      bool `json:"semantic_search"`
	MaxNotebooks        int  `json:"max_notebooks"`
	MaxNotesPerNotebook int  `json:"max_notes_per_notebook"`
}

// âœ… UPDATED: Include Features
type SubscriptionStatusResponse struct {
	SubscriptionId           uuid.UUID            `json:"subscription_id"`
	PlanName                 string               `json:"plan_name"`
	Status                   string               `json:"status"`
	CurrentPeriodEnd         time.Time            `json:"current_period_end"`
	AiChatDailyLimit         int                  `json:"ai_chat_daily_limit"`
	SemanticSearchDailyLimit int                  `json:"semantic_search_daily_limit"`
	IsActive                 bool                 `json:"is_active"`
	Features                 SubscriptionFeatures `json:"features"`
}



>>> FILE: D:\notetaker\notefiber-BE\internal\service\user_service.go
// FILE: internal/service/user_service.go
package service

import (
	"context"
	"fmt"
	"io"
	"mime/multipart"
	"os"
	"path/filepath"
	"time"

	"ai-notetaking-be/internal/dto"
	"ai-notetaking-be/internal/entity"
	"ai-notetaking-be/internal/repository/specification"
	"ai-notetaking-be/internal/repository/unitofwork"

	"github.com/google/uuid"
)

type IUserService interface {
	GetProfile(ctx context.Context, userId uuid.UUID) (*dto.UserProfileResponse, error)
	UpdateProfile(ctx context.Context, userId uuid.UUID, req *dto.UpdateProfileRequest) error
	DeleteAccount(ctx context.Context, userId uuid.UUID) error
	UploadAvatar(ctx context.Context, userId uuid.UUID, file *multipart.FileHeader) (string, error)
	RequestRefund(ctx context.Context, userId uuid.UUID, req dto.UserRefundRequest) (*dto.UserRefundResponse, error)
}

type userService struct {
	uowFactory unitofwork.RepositoryFactory
}

// NewUserService now accepts RepositoryFactory instead of direct repository
func NewUserService(uowFactory unitofwork.RepositoryFactory) IUserService {
	return &userService{uowFactory: uowFactory}
}

func (s *userService) GetProfile(ctx context.Context, userId uuid.UUID) (*dto.UserProfileResponse, error) {
	uow := s.uowFactory.NewUnitOfWork(ctx)
	// Use GetByIdWithAvatar which we added to contract to maintain compatibility
	user, err := uow.UserRepository().GetByIdWithAvatar(ctx, userId)
	if err != nil {
		return nil, err
	}

	if user == nil {
		return nil, fmt.Errorf("user not found")
	}

	avatarURL := ""
	if user.AvatarURL != nil {
		avatarURL = *user.AvatarURL
	}

	return &dto.UserProfileResponse{
		Id:           user.Id,
		Email:        user.Email,
		FullName:     user.FullName,
		Role:         string(user.Role),
		Status:       string(user.Status),
		AvatarURL:    avatarURL,
		AiDailyUsage: user.AiDailyUsage,
		CreatedAt:    user.CreatedAt,
	}, nil
}

func (s *userService) UpdateProfile(ctx context.Context, userId uuid.UUID, req *dto.UpdateProfileRequest) error {
	uow := s.uowFactory.NewUnitOfWork(ctx)
	// Transaction could be useful here but for single update GORM is atomic enough.
	// For consistency, let's use Begin/Commit pattern if we were doing more.

	repo := uow.UserRepository()
	user, err := repo.FindOne(ctx, specification.ByID{ID: userId})
	if err != nil {
		return err
	}
	if user == nil {
		return fmt.Errorf("user not found")
	}

	user.FullName = req.FullName
	return repo.Update(ctx, user)
}

func (s *userService) DeleteAccount(ctx context.Context, userId uuid.UUID) error {
	uow := s.uowFactory.NewUnitOfWork(ctx)
	return uow.UserRepository().Delete(ctx, userId)
}

func (s *userService) UploadAvatar(ctx context.Context, userId uuid.UUID, file *multipart.FileHeader) (string, error) {
	// 1. Validate File Size (e.g., Max 2MB)
	if file.Size > 2*1024*1024 {
		return "", fmt.Errorf("file too large (max 2MB)")
	}

	// 2. Open File
	src, err := file.Open()
	if err != nil {
		return "", err
	}
	defer src.Close()

	// 3. Create Upload Directory
	uploadDir := "./uploads/avatars"
	if err := os.MkdirAll(uploadDir, 0755); err != nil {
		return "", err
	}

	// 4. Generate Unique Filename
	ext := filepath.Ext(file.Filename)
	filename := fmt.Sprintf("%s_%d%s", userId.String(), time.Now().Unix(), ext)
	dstPath := filepath.Join(uploadDir, filename)

	// 5. Save File
	dst, err := os.Create(dstPath)
	if err != nil {
		return "", err
	}
	defer dst.Close()

	if _, err = io.Copy(dst, src); err != nil {
		return "", err
	}

	// 6. Generate Public URL
	baseURL := os.Getenv("APP_BASE_URL")
	if baseURL == "" {
		baseURL = "http://localhost:3000"
	}
	publicURL := fmt.Sprintf("%s/uploads/avatars/%s", baseURL, filename)

	// 7. Update User Profile in DB
	uow := s.uowFactory.NewUnitOfWork(ctx)
	err = uow.UserRepository().UpdateAvatar(ctx, userId, publicURL)
	if err != nil {
		return "", err
	}

	return publicURL, nil
}

// RequestRefund creates a new refund request for a user's subscription
func (s *userService) RequestRefund(ctx context.Context, userId uuid.UUID, req dto.UserRefundRequest) (*dto.UserRefundResponse, error) {
	uow := s.uowFactory.NewUnitOfWork(ctx)

	// 1. Validate subscription exists and belongs to user
	sub, err := uow.SubscriptionRepository().FindOneSubscription(ctx,
		specification.ByID{ID: req.SubscriptionId},
		specification.Filter("user_id", userId),
	)
	if err != nil {
		return nil, err
	}
	if sub == nil {
		return nil, fmt.Errorf("subscription not found")
	}

	// 2. Check subscription is active and paid
	if sub.Status != entity.SubscriptionStatusActive {
		return nil, fmt.Errorf("subscription is not active")
	}
	if sub.PaymentStatus != entity.PaymentStatusPaid {
		return nil, fmt.Errorf("subscription is not eligible for refund")
	}

	// 3. Check if refund already requested for this subscription
	existingRefund, err := uow.RefundRepository().FindOne(ctx, specification.Filter("subscription_id", req.SubscriptionId))
	if err != nil {
		return nil, err
	}
	if existingRefund != nil {
		return nil, fmt.Errorf("refund already requested for this subscription")
	}

	// 4. Get plan price for refund amount
	plan, err := uow.SubscriptionRepository().FindOnePlan(ctx, specification.ByID{ID: sub.PlanId})
	if err != nil {
		return nil, err
	}
	refundAmount := 0.0
	if plan != nil {
		refundAmount = plan.Price
	}

	// 5. Create refund record with status pending
	refundId := uuid.New()
	refund := &entity.Refund{
		ID:             refundId,
		SubscriptionID: req.SubscriptionId,
		UserID:         userId,
		Amount:         refundAmount,
		Reason:         req.Reason,
		Status:         string(entity.RefundStatusPending),
		CreatedAt:      time.Now(),
	}

	if err := uow.RefundRepository().Create(ctx, refund); err != nil {
		return nil, err
	}

	return &dto.UserRefundResponse{
		RefundId: refundId.String(),
		Status:   string(entity.RefundStatusPending),
		Message:  "Your refund request has been submitted and is awaiting admin review.",
	}, nil
}



>>> FILE: D:\notetaker\notefiber-BE\internal\repository\implementation\user_repository_impl.go
package implementation

import (
	"context"
	"errors"
	"time"

	"ai-notetaking-be/internal/entity"
	"ai-notetaking-be/internal/mapper"
	"ai-notetaking-be/internal/model"
	"ai-notetaking-be/internal/repository/contract"
	"ai-notetaking-be/internal/repository/specification"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

type UserRepositoryImpl struct {
	db     *gorm.DB
	mapper *mapper.UserMapper
}

func NewUserRepository(db *gorm.DB) contract.UserRepository {
	return &UserRepositoryImpl{
		db:     db,
		mapper: mapper.NewUserMapper(),
	}
}

func (r *UserRepositoryImpl) applySpecifications(db *gorm.DB, specs ...specification.Specification) *gorm.DB {
	for _, spec := range specs {
		db = spec.Apply(db)
	}
	return db
}

func (r *UserRepositoryImpl) Create(ctx context.Context, user *entity.User) error {
	modelUser := r.mapper.ToModel(user)
	if err := r.db.WithContext(ctx).Create(modelUser).Error; err != nil {
		return err
	}
	*user = *r.mapper.ToEntity(modelUser)
	return nil
}

func (r *UserRepositoryImpl) Update(ctx context.Context, user *entity.User) error {
	modelUser := r.mapper.ToModel(user)
	if err := r.db.WithContext(ctx).Save(modelUser).Error; err != nil {
		return err
	}
	*user = *r.mapper.ToEntity(modelUser)
	return nil
}

func (r *UserRepositoryImpl) Delete(ctx context.Context, id uuid.UUID) error {
	return r.db.WithContext(ctx).Where("id = ?", id).Delete(&model.User{}).Error
}

func (r *UserRepositoryImpl) FindOne(ctx context.Context, specs ...specification.Specification) (*entity.User, error) {
	var modelUser model.User
	query := r.applySpecifications(r.db.WithContext(ctx), specs...)

	if err := query.First(&modelUser).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}

	return r.mapper.ToEntity(&modelUser), nil
}

func (r *UserRepositoryImpl) FindAll(ctx context.Context, specs ...specification.Specification) ([]*entity.User, error) {
	var modelUsers []*model.User
	query := r.applySpecifications(r.db.WithContext(ctx), specs...)

	if err := query.Find(&modelUsers).Error; err != nil {
		return nil, err
	}

	return r.mapper.ToEntities(modelUsers), nil
}

func (r *UserRepositoryImpl) Count(ctx context.Context, specs ...specification.Specification) (int64, error) {
	var count int64
	query := r.applySpecifications(r.db.WithContext(ctx).Model(&model.User{}), specs...)
	if err := query.Count(&count).Error; err != nil {
		return 0, err
	}
	return count, nil
}

// FindOneUnscoped finds a user including soft-deleted ones (ignores deleted_at filter)
func (r *UserRepositoryImpl) FindOneUnscoped(ctx context.Context, specs ...specification.Specification) (*entity.User, error) {
	var modelUser model.User
	query := r.applySpecifications(r.db.WithContext(ctx).Unscoped(), specs...)

	if err := query.First(&modelUser).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}

	return r.mapper.ToEntity(&modelUser), nil
}

// Restore reactivates a soft-deleted user by clearing deleted_at
func (r *UserRepositoryImpl) Restore(ctx context.Context, id uuid.UUID) error {
	return r.db.WithContext(ctx).Unscoped().Model(&model.User{}).
		Where("id = ?", id).
		Updates(map[string]interface{}{
			"deleted_at": nil,
			"status":     "active",
		}).Error
}

// Token Implementations

func (r *UserRepositoryImpl) CreatePasswordResetToken(ctx context.Context, token *entity.PasswordResetToken) error {
	m := r.mapper.PasswordResetTokenToModel(token)
	if err := r.db.WithContext(ctx).Create(m).Error; err != nil {
		return err
	}
	return nil
}

func (r *UserRepositoryImpl) FindPasswordResetToken(ctx context.Context, specs ...specification.Specification) (*entity.PasswordResetToken, error) {
	var m model.PasswordResetToken
	query := r.applySpecifications(r.db.WithContext(ctx), specs...)
	if err := query.First(&m).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return r.mapper.PasswordResetTokenToEntity(&m), nil
}

func (r *UserRepositoryImpl) CreateEmailVerificationToken(ctx context.Context, token *entity.EmailVerificationToken) error {
	m := r.mapper.EmailVerificationTokenToModel(token)
	if err := r.db.WithContext(ctx).Create(m).Error; err != nil {
		return err
	}
	return nil
}

func (r *UserRepositoryImpl) FindEmailVerificationToken(ctx context.Context, specs ...specification.Specification) (*entity.EmailVerificationToken, error) {
	var m model.EmailVerificationToken
	query := r.applySpecifications(r.db.WithContext(ctx), specs...)
	if err := query.First(&m).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return r.mapper.EmailVerificationTokenToEntity(&m), nil
}

func (r *UserRepositoryImpl) CreateRefreshToken(ctx context.Context, token *entity.UserRefreshToken) error {
	m := r.mapper.UserRefreshTokenToModel(token)
	if err := r.db.WithContext(ctx).Create(m).Error; err != nil {
		return err
	}
	return nil
}

// Extended Implementation

func (r *UserRepositoryImpl) MarkTokenUsed(ctx context.Context, id uuid.UUID) error {
	return r.db.WithContext(ctx).Model(&model.PasswordResetToken{}).Where("id = ?", id).Update("used", true).Error
}

func (r *UserRepositoryImpl) DeleteEmailVerificationToken(ctx context.Context, id uuid.UUID) error {
	return r.db.WithContext(ctx).Delete(&model.EmailVerificationToken{}, id).Error
}

func (r *UserRepositoryImpl) RevokeRefreshToken(ctx context.Context, tokenHash string) error {
	return r.db.WithContext(ctx).Model(&model.UserRefreshToken{}).Where("token_hash = ?", tokenHash).Update("revoked", true).Error
}

func (r *UserRepositoryImpl) GetByIdWithAvatar(ctx context.Context, id uuid.UUID) (*entity.User, error) {
	var result struct {
		model.User
		AvatarUrlResolved *string `gorm:"column:avatar_url_resolved"`
	}

	err := r.db.WithContext(ctx).Table("users").
		Select("users.*, COALESCE(users.avatar_url, user_providers.avatar_url) as avatar_url_resolved").
		Joins("LEFT JOIN user_providers ON users.id = user_providers.user_id").
		Where("users.id = ?", id).
		Order("user_providers.created_at DESC").
		Limit(1).
		Scan(&result).Error

	if err != nil {
		// Scan with Limit 1 might not behave like First (returning valid record or error).
		// If ID not found, result fields will be zero.
		if result.Id == uuid.Nil {
			return nil, nil
		}
		return nil, err
	}

	if result.Id == uuid.Nil {
		return nil, nil
	}

	user := r.mapper.ToEntity(&result.User)
	if result.AvatarUrlResolved != nil {
		user.AvatarURL = result.AvatarUrlResolved
	}

	return user, nil
}

func (r *UserRepositoryImpl) ActivateUser(ctx context.Context, userId uuid.UUID) error {
	now := time.Now()
	// Using map for updates
	return r.db.WithContext(ctx).Model(&model.User{}).Where("id = ?", userId).
		Updates(map[string]interface{}{
			"status":            "active",
			"email_verified":    true,
			"email_verified_at": now,
		}).Error
}

func (r *UserRepositoryImpl) UpdateStatus(ctx context.Context, id uuid.UUID, status string) error {
	return r.db.WithContext(ctx).Model(&model.User{}).Where("id = ?", id).Update("status", status).Error
}

func (r *UserRepositoryImpl) UpdateAvatar(ctx context.Context, userId uuid.UUID, avatarURL string) error {
	return r.db.WithContext(ctx).Model(&model.User{}).Where("id = ?", userId).Update("avatar_url", avatarURL).Error
}

func (r *UserRepositoryImpl) UpdatePassword(ctx context.Context, userId uuid.UUID, hash string) error {
	return r.db.WithContext(ctx).Model(&model.User{}).Where("id = ?", userId).Update("password_hash", hash).Error
}

func (r *UserRepositoryImpl) SaveUserProvider(ctx context.Context, provider *entity.UserProvider) error {
	m := r.mapper.UserProviderToModel(provider)
	return r.db.WithContext(ctx).Exec(`
		INSERT INTO user_providers (id, user_id, provider_name, provider_user_id, avatar_url, created_at)
		VALUES (?, ?, ?, ?, ?, ?)
		ON CONFLICT (provider_name, provider_user_id) 
		DO UPDATE SET avatar_url = EXCLUDED.avatar_url
	`, m.Id, m.UserId, m.ProviderName, m.ProviderUserId, m.AvatarURL, m.CreatedAt).Error
}

func (r *UserRepositoryImpl) SearchUsers(ctx context.Context, query string, limit, offset int) ([]*entity.User, error) {
	var models []*model.User
	pattern := "%" + query + "%"
	err := r.db.WithContext(ctx).
		Where("email ILIKE ? OR full_name ILIKE ?", pattern, pattern).
		Order("created_at DESC").
		Limit(limit).
		Offset(offset).
		Find(&models).Error

	if err != nil {
		return nil, err
	}
	return r.mapper.ToEntities(models), nil
}

func (r *UserRepositoryImpl) GetUserGrowth(ctx context.Context) ([]map[string]interface{}, error) {
	var results []map[string]interface{}
	err := r.db.WithContext(ctx).Raw(`
		SELECT to_char(created_at, 'YYYY-MM-DD') as date, COUNT(*) as count 
		FROM users 
		WHERE created_at > NOW() - INTERVAL '30 days' 
		GROUP BY date 
		ORDER BY date ASC
	`).Scan(&results).Error
	return results, err
}

func (r *UserRepositoryImpl) CountByStatus(ctx context.Context, status string) (int, error) {
	var count int64
	err := r.db.WithContext(ctx).Model(&model.User{}).Where("status = ?", status).Count(&count).Error
	return int(count), err
}



>>> FILE: D:\notetaker\notefiber-BE\internal\controller\payment_controller.go
// FILE: internal/controller/payment_controller.go
package controller

import (
	"ai-notetaking-be/internal/dto"
	"ai-notetaking-be/internal/pkg/serverutils"
	"ai-notetaking-be/internal/service"
	"fmt"
	"os"

	"github.com/gofiber/fiber/v2"
	"github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
)

type IPaymentController interface {
	RegisterRoutes(r fiber.Router)
	GetPlans(ctx *fiber.Ctx) error
	GetOrderSummary(ctx *fiber.Ctx) error // NEW
	Checkout(ctx *fiber.Ctx) error
	Webhook(ctx *fiber.Ctx) error
	GetStatus(ctx *fiber.Ctx) error
	CancelSubscription(ctx *fiber.Ctx) error
}

type paymentController struct {
	service service.IPaymentService
}

func NewPaymentController(service service.IPaymentService) IPaymentController {
	return &paymentController{service: service}
}

func (c *paymentController) RegisterRoutes(r fiber.Router) {
	h := r.Group("/payment")
	h.Post("/midtrans/notification", c.Webhook)
	h.Get("/plans", c.GetPlans)
	h.Get("/summary", c.GetOrderSummary) // Public route, just needs plan_id

	// Protected Routes
	h.Post("/checkout", c.authMiddleware, c.Checkout)
	h.Get("/status", c.authMiddleware, c.GetStatus)
	h.Post("/cancel", c.authMiddleware, c.CancelSubscription)
}

func (c *paymentController) authMiddleware(ctx *fiber.Ctx) error {
	authHeader := ctx.Get("Authorization")
	if len(authHeader) < 7 || authHeader[:7] != "Bearer " {
		return ctx.Status(fiber.StatusUnauthorized).JSON(fiber.Map{"message": "Missing token"})
	}
	tokenStr := authHeader[7:]

	token, err := jwt.Parse(tokenStr, func(t *jwt.Token) (interface{}, error) {
		return []byte(os.Getenv("JWT_SECRET")), nil
	})

	if err != nil || !token.Valid {
		return ctx.Status(fiber.StatusUnauthorized).JSON(fiber.Map{"message": "Invalid token"})
	}

	claims, ok := token.Claims.(jwt.MapClaims)
	if !ok {
		return ctx.Status(fiber.StatusUnauthorized).JSON(fiber.Map{"message": "Invalid claims"})
	}

	ctx.Locals("user_id", claims["user_id"])
	return ctx.Next()
}

func (c *paymentController) GetPlans(ctx *fiber.Ctx) error {
	res, err := c.service.GetPlans(ctx.Context())
	if err != nil {
		return err
	}
	return ctx.JSON(serverutils.SuccessResponse("Success fetching plans", res))
}

// NEW Handler
func (c *paymentController) GetOrderSummary(ctx *fiber.Ctx) error {
	planIdStr := ctx.Query("plan_id")
	if planIdStr == "" {
		return ctx.Status(fiber.StatusBadRequest).JSON(serverutils.ErrorResponse(400, "plan_id is required"))
	}

	planId, err := uuid.Parse(planIdStr)
	if err != nil {
		return ctx.Status(fiber.StatusBadRequest).JSON(serverutils.ErrorResponse(400, "invalid plan_id format"))
	}

	res, err := c.service.GetOrderSummary(ctx.Context(), planId)
	if err != nil {
		return ctx.Status(fiber.StatusInternalServerError).JSON(serverutils.ErrorResponse(500, err.Error()))
	}
	return ctx.JSON(serverutils.SuccessResponse("Order summary", res))
}

func (c *paymentController) Checkout(ctx *fiber.Ctx) error {
	var req dto.CheckoutRequest
	if err := ctx.BodyParser(&req); err != nil {
		return err
	}
	if err := serverutils.ValidateRequest(req); err != nil {
		return err
	}

	userIdStr := ctx.Locals("user_id").(string)
	userId, _ := uuid.Parse(userIdStr)

	res, err := c.service.CreateSubscription(ctx.Context(), userId, &req)
	if err != nil {
		return ctx.Status(fiber.StatusInternalServerError).JSON(serverutils.ErrorResponse(500, err.Error()))
	}
	return ctx.JSON(serverutils.SuccessResponse("Subscription created", res))
}

func (c *paymentController) Webhook(ctx *fiber.Ctx) error {
	var req dto.MidtransWebhookRequest
	if err := ctx.BodyParser(&req); err != nil {
		fmt.Printf("[WEBHOOK ERROR] Body parsing failed: %v\n", err)
		return ctx.SendStatus(fiber.StatusBadRequest)
	}

	sigPreview := req.SignatureKey
	if len(sigPreview) > 8 {
		sigPreview = sigPreview[:8] + "..."
	}
	fmt.Printf("[WEBHOOK] Received: OrderId=%s, Status=%s, SignatureKey=%s\n",
		req.OrderId, req.TransactionStatus, sigPreview)

	err := c.service.HandleNotification(ctx.Context(), &req)
	if err != nil {
		fmt.Printf("[WEBHOOK ERROR] Service handling failed for OrderId=%s: %v\n", req.OrderId, err)
		// Return 500 so Midtrans will retry the notification
		return ctx.SendStatus(fiber.StatusInternalServerError)
	}

	fmt.Printf("[WEBHOOK] Successfully processed OrderId=%s\n", req.OrderId)
	return ctx.SendStatus(fiber.StatusOK)
}

func (c *paymentController) GetStatus(ctx *fiber.Ctx) error {
	userIdStr := ctx.Locals("user_id").(string)
	userId, _ := uuid.Parse(userIdStr)

	res, err := c.service.GetSubscriptionStatus(ctx.Context(), userId)
	if err != nil {
		return ctx.Status(fiber.StatusInternalServerError).JSON(serverutils.ErrorResponse(500, err.Error()))
	}
	return ctx.JSON(serverutils.SuccessResponse("Subscription status", res))
}

func (c *paymentController) CancelSubscription(ctx *fiber.Ctx) error {
	userIdStr := ctx.Locals("user_id").(string)
	userId, _ := uuid.Parse(userIdStr)

	err := c.service.CancelSubscription(ctx.Context(), userId)
	if err != nil {
		return ctx.Status(fiber.StatusInternalServerError).JSON(serverutils.ErrorResponse(500, err.Error()))
	}
	return ctx.JSON(serverutils.SuccessResponse[any]("Subscription canceled", nil))
}



>>> FILE: D:\notetaker\notefiber-BE\internal\service\payment_service.go
// FILE: internal/service/payment_service.go
package service

import (
	"context"
	"crypto/sha512"
	"errors"
	"fmt"
	"os"
	"time"

	"ai-notetaking-be/internal/dto"
	"ai-notetaking-be/internal/entity"
	"ai-notetaking-be/internal/repository/specification"
	"ai-notetaking-be/internal/repository/unitofwork"

	"github.com/google/uuid"
	"github.com/midtrans/midtrans-go"
	"github.com/midtrans/midtrans-go/snap"
)

type IPaymentService interface {
	GetPlans(ctx context.Context) ([]*dto.PlanResponse, error)
	GetOrderSummary(ctx context.Context, planId uuid.UUID) (*dto.OrderSummaryResponse, error)
	CreateSubscription(ctx context.Context, userId uuid.UUID, req *dto.CheckoutRequest) (*dto.CheckoutResponse, error)
	HandleNotification(ctx context.Context, req *dto.MidtransWebhookRequest) error
	GetSubscriptionStatus(ctx context.Context, userId uuid.UUID) (*dto.SubscriptionStatusResponse, error)
	CancelSubscription(ctx context.Context, userId uuid.UUID) error
}

type paymentService struct {
	uowFactory unitofwork.RepositoryFactory
}

func NewPaymentService(uowFactory unitofwork.RepositoryFactory) IPaymentService {
	return &paymentService{
		uowFactory: uowFactory,
	}
}

func (s *paymentService) GetPlans(ctx context.Context) ([]*dto.PlanResponse, error) {
	uow := s.uowFactory.NewUnitOfWork(ctx)
	// We might need an OrderBy spec for plans? Legacy didn't specify.
	plans, err := uow.SubscriptionRepository().FindAllPlans(ctx)
	if err != nil {
		return nil, err
	}

	var res []*dto.PlanResponse
	for _, p := range plans {
		features := []string{"Basic Note Taking"}
		if p.SemanticSearchEnabled {
			features = append(features, "Semantic Search")
		}
		if p.AiChatEnabled {
			features = append(features, "AI Chat Assistant")
		}

		res = append(res, &dto.PlanResponse{
			Id:          p.Id,
			Name:        p.Name,
			Slug:        p.Slug,
			Price:       p.Price,
			Description: p.Description,
			Features:    features,
		})
	}
	return res, nil
}

func (s *paymentService) GetOrderSummary(ctx context.Context, planId uuid.UUID) (*dto.OrderSummaryResponse, error) {
	uow := s.uowFactory.NewUnitOfWork(ctx)
	plan, err := uow.SubscriptionRepository().FindOnePlan(ctx, specification.ByID{ID: planId})
	if err != nil {
		return nil, err
	}
	if plan == nil {
		return nil, errors.New("plan not found")
	}

	subtotal := plan.Price
	taxRate := plan.TaxRate
	tax := subtotal * taxRate
	total := subtotal + tax

	billingPeriod := "month"
	if plan.BillingPeriod == entity.BillingPeriodYearly {
		billingPeriod = "year"
	}

	return &dto.OrderSummaryResponse{
		PlanName:      plan.Name,
		BillingPeriod: billingPeriod,
		PricePerUnit:  fmt.Sprintf("$%.2f/%s", plan.Price, billingPeriod),
		Subtotal:      subtotal,
		Tax:           tax,
		Total:         total,
		Currency:      "USD",
	}, nil
}

func (s *paymentService) CreateSubscription(ctx context.Context, userId uuid.UUID, req *dto.CheckoutRequest) (*dto.CheckoutResponse, error) {
	uow := s.uowFactory.NewUnitOfWork(ctx)

	plan, err := uow.SubscriptionRepository().FindOnePlan(ctx, specification.ByID{ID: req.PlanId})
	if err != nil {
		return nil, err
	}
	if plan == nil {
		return nil, errors.New("plan not found")
	}

	// Use generic FindOne
	user, err := uow.UserRepository().FindOne(ctx, specification.ByID{ID: userId})
	if err != nil {
		return nil, err
	}
	if user == nil {
		return nil, errors.New("user not found")
	}

	billingId := uuid.New()
	billingAddr := &entity.BillingAddress{
		Id:           billingId,
		UserId:       userId,
		FirstName:    req.FirstName,
		LastName:     req.LastName,
		Email:        req.Email,
		Phone:        req.Phone,
		AddressLine1: req.AddressLine1,
		AddressLine2: req.AddressLine2,
		City:         req.City,
		State:        req.State,
		PostalCode:   req.PostalCode,
		Country:      req.Country,
		IsDefault:    true,
		CreatedAt:    time.Now(),
		UpdatedAt:    time.Now(),
	}

	subId := uuid.New()
	sub := &entity.UserSubscription{
		Id:                 subId,
		UserId:             userId,
		PlanId:             plan.Id,
		BillingAddressId:   &billingId,
		Status:             entity.SubscriptionStatusInactive,
		PaymentStatus:      entity.PaymentStatusPending,
		CreatedAt:          time.Now(),
		UpdatedAt:          time.Now(),
		CurrentPeriodStart: time.Now(),
		CurrentPeriodEnd:   time.Now().AddDate(0, 1, 0),
	}

	if plan.BillingPeriod == entity.BillingPeriodYearly {
		sub.CurrentPeriodEnd = time.Now().AddDate(1, 0, 0)
	}

	// Transaction
	if err := uow.Begin(ctx); err != nil {
		return nil, err
	}
	defer uow.Rollback()

	if err := uow.BillingRepository().Create(ctx, billingAddr); err != nil {
		return nil, fmt.Errorf("failed to save billing address: %v", err)
	}

	if err := uow.SubscriptionRepository().CreateSubscription(ctx, sub); err != nil {
		return nil, err
	}

	if err := uow.Commit(); err != nil {
		return nil, err
	}

	// -- Midtrans Logic (External Service calls usually outside DB tx, safe here after commit) --
	var sClient snap.Client
	serverKey := os.Getenv("MIDTRANS_SERVER_KEY")
	env := midtrans.Sandbox
	if os.Getenv("MIDTRANS_IS_PRODUCTION") == "true" {
		env = midtrans.Production
	}
	sClient.New(serverKey, env)

	frontendURL := os.Getenv("FRONTEND_URL")
	finishRedirectURL := fmt.Sprintf("%s/app?payment=success", frontendURL)

	taxRate := plan.TaxRate
	finalAmount := int64(plan.Price + (plan.Price * taxRate))

	midtransPostalCode := req.PostalCode
	if len(midtransPostalCode) > 5 {
		midtransPostalCode = midtransPostalCode[:5]
	}

	snapReq := &snap.Request{
		TransactionDetails: midtrans.TransactionDetails{
			OrderID:  subId.String(),
			GrossAmt: finalAmount,
		},
		CreditCard: &snap.CreditCardDetails{
			Secure: true,
		},
		Callbacks: &snap.Callbacks{
			Finish: finishRedirectURL,
		},
		CustomerDetail: &midtrans.CustomerDetails{
			FName: req.FirstName,
			LName: req.LastName,
			Email: req.Email,
			Phone: req.Phone,
			BillAddr: &midtrans.CustomerAddress{
				FName:       req.FirstName,
				LName:       req.LastName,
				Phone:       req.Phone,
				Address:     req.AddressLine1,
				City:        req.City,
				Postcode:    midtransPostalCode,
				CountryCode: "IDN",
			},
		},
		Items: &[]midtrans.ItemDetails{
			{
				ID:    plan.Id.String(),
				Price: int64(plan.Price),
				Qty:   1,
				Name:  plan.Name,
			},
		},
		EnabledPayments: snap.AllSnapPaymentType,
	}

	snapResp, midErr := sClient.CreateTransaction(snapReq)
	if midErr != nil {
		return nil, fmt.Errorf("midtrans error: %v", midErr.GetMessage())
	}

	return &dto.CheckoutResponse{
		SubscriptionId:  subId,
		SnapToken:       snapResp.Token,
		SnapRedirectUrl: snapResp.RedirectURL,
	}, nil
}

func (s *paymentService) HandleNotification(ctx context.Context, req *dto.MidtransWebhookRequest) error {
	fmt.Printf("\n[WEBHOOK] ========== Processing Notification ==========\n")
	fmt.Printf("[WEBHOOK] OrderId: %s | Status: %s\n", req.OrderId, req.TransactionStatus)

	// P2: Signature Validation
	serverKey := os.Getenv("MIDTRANS_SERVER_KEY")
	if serverKey == "" {
		fmt.Println("[WEBHOOK ERROR] MIDTRANS_SERVER_KEY not configured")
		return fmt.Errorf("server configuration error")
	}

	// Midtrans signature = SHA512(order_id + status_code + gross_amount + server_key)
	signatureInput := req.OrderId + req.StatusCode + req.GrossAmount + serverKey
	expectedSignature := fmt.Sprintf("%x", sha512.Sum512([]byte(signatureInput)))

	if req.SignatureKey != expectedSignature {
		fmt.Printf("[WEBHOOK ERROR] Signature mismatch for OrderId=%s\n", req.OrderId)
		fmt.Printf("[WEBHOOK DEBUG] Expected: %s...\n", expectedSignature[:16])
		fmt.Printf("[WEBHOOK DEBUG] Received: %s...\n", req.SignatureKey[:16])
		return fmt.Errorf("invalid signature")
	}
	fmt.Printf("[WEBHOOK] Signature validated successfully\n")

	// Parse subscription ID from order_id
	subId, err := uuid.Parse(req.OrderId)
	if err != nil {
		fmt.Printf("[WEBHOOK ERROR] Invalid order_id format: %s\n", req.OrderId)
		return fmt.Errorf("invalid order id format")
	}

	// P1: Transaction wrapper
	uow := s.uowFactory.NewUnitOfWork(ctx)
	if err := uow.Begin(ctx); err != nil {
		fmt.Printf("[WEBHOOK ERROR] Failed to begin transaction: %v\n", err)
		return err
	}
	defer uow.Rollback()

	sub, err := uow.SubscriptionRepository().FindOneSubscription(ctx, specification.ByID{ID: subId})
	if err != nil {
		fmt.Printf("[WEBHOOK ERROR] Database error finding subscription: %v\n", err)
		return err
	}
	if sub == nil {
		fmt.Printf("[WEBHOOK ERROR] Subscription not found: %s\n", req.OrderId)
		return fmt.Errorf("subscription not found")
	}

	fmt.Printf("[WEBHOOK] Found subscription: UserId=%s, CurrentStatus=%s, PaymentStatus=%s\n",
		sub.UserId, sub.Status, sub.PaymentStatus)

	// Determine new status based on transaction status
	var newStatus entity.SubscriptionStatus
	var newPaymentStatus entity.PaymentStatus

	switch req.TransactionStatus {
	case "capture", "settlement":
		newStatus = entity.SubscriptionStatusActive
		newPaymentStatus = entity.PaymentStatusPaid
		fmt.Printf("[WEBHOOK] Payment SUCCESS - will activate subscription\n")
	case "deny", "cancel", "expire":
		newStatus = entity.SubscriptionStatusInactive
		newPaymentStatus = entity.PaymentStatusFailed
		fmt.Printf("[WEBHOOK] Payment FAILED - will deactivate subscription\n")
	case "pending":
		fmt.Printf("[WEBHOOK] Payment PENDING - no action needed\n")
		return nil
	default:
		fmt.Printf("[WEBHOOK] Unknown status '%s' - no action taken\n", req.TransactionStatus)
		return nil
	}

	// Check if update is needed
	if sub.Status == newStatus && sub.PaymentStatus == newPaymentStatus {
		fmt.Printf("[WEBHOOK] Status already up-to-date, skipping update\n")
		return nil
	}

	// P3: Log state transition
	fmt.Printf("[WEBHOOK] State transition: Status(%s→%s), PaymentStatus(%s→%s)\n",
		sub.Status, newStatus, sub.PaymentStatus, newPaymentStatus)

	// Apply changes
	sub.Status = newStatus
	sub.PaymentStatus = newPaymentStatus

	if err := uow.SubscriptionRepository().UpdateSubscription(ctx, sub); err != nil {
		fmt.Printf("[WEBHOOK ERROR] Failed to update subscription: %v\n", err)
		return err
	}

	if err := uow.Commit(); err != nil {
		fmt.Printf("[WEBHOOK ERROR] Failed to commit transaction: %v\n", err)
		return err
	}

	fmt.Printf("[WEBHOOK] ✅ Successfully updated subscription %s\n", subId)
	fmt.Printf("[WEBHOOK] ===========================================\n\n")
	return nil
}

func (s *paymentService) GetSubscriptionStatus(ctx context.Context, userId uuid.UUID) (*dto.SubscriptionStatusResponse, error) {
	uow := s.uowFactory.NewUnitOfWork(ctx)

	// Assuming "ActiveByUserId" means status=active and user_id=userId
	// NOTE: Need to support finding by UserID AND Status.
	// I need a Specification for ByStatus? Or SubscriptionStatus spec.
	// Or I can just FindAll and filter? (bad).
	// Let's create a specific Specification for Subscription?
	// Or just use generic Where clause via custom spec if needed, OR add `ByStatus` to common specs?
	// `ActiveUsers` exists in `user_specifications`.
	// I'll assume we can find by UserID and inspect results, typically user has 1 active sub.
	// Let's assume finding LAST created subscription for user?
	// The helper `GetActiveByUserId` in legacy likely did: WHERE user_id = ? AND status = 'active' ORDER BY created_at DESC LIMIT 1.

	// Create Custom Spec inline or assume I can fetch all for user.
	// Let's create `specification.UserOwnedBy` (Already exists).
	// And `specification.SubscriptionStatusIs{Status}`?
	// I'll rely on `UserOwnedBy` and manual filter if spec missing, or add spec.
	// Actually better to just add `Specification.ByStatus`?
	// Let's use `specification.UserOwnedBy` and filter in code (assuming low volume) OR
	// assume I added `specification.ByStatus`.

	// I will just use `UserOwnedBy` and pick the active one.
	// Order by created_at DESC to get most recent subscriptions first
	subs, err := uow.SubscriptionRepository().FindAllSubscriptions(ctx,
		specification.UserOwnedBy{UserID: userId},
		specification.OrderBy{Field: "created_at", Desc: true},
	)
	if err != nil {
		return nil, err
	}

	// Find the most recent active subscription with valid period
	var activeSub *entity.UserSubscription
	for _, sub := range subs {
		// First priority: active status with valid period
		if sub.Status == entity.SubscriptionStatusActive && sub.CurrentPeriodEnd.After(time.Now()) {
			activeSub = sub
			break
		}
	}

	// If no active found, check if there's a recently paid one that should be active
	if activeSub == nil {
		for _, sub := range subs {
			// Second priority: payment succeeded but status might not be updated yet
			if sub.PaymentStatus == entity.PaymentStatusPaid && sub.CurrentPeriodEnd.After(time.Now()) {
				activeSub = sub
				break
			}
		}
	}

	if activeSub == nil {
		return &dto.SubscriptionStatusResponse{
			PlanName: "Free Plan",
			Status:   "inactive",
			IsActive: false,
			Features: dto.SubscriptionFeatures{
				AiChat:              false,
				SemanticSearch:      false,
				MaxNotebooks:        3,
				MaxNotesPerNotebook: 10,
			},
		}, nil
	}

	// Get Plan
	plan, err := uow.SubscriptionRepository().FindOnePlan(ctx, specification.ByID{ID: activeSub.PlanId})
	if err != nil {
		return nil, err
	}
	if plan == nil {
		return nil, errors.New("plan not found for active subscription")
	}

	return &dto.SubscriptionStatusResponse{
		SubscriptionId:           activeSub.Id,
		PlanName:                 plan.Name,
		Status:                   string(activeSub.Status),
		CurrentPeriodEnd:         activeSub.CurrentPeriodEnd,
		AiChatDailyLimit:         plan.AiChatDailyLimit,
		SemanticSearchDailyLimit: plan.SemanticSearchDailyLimit,
		IsActive:                 true,
		Features: dto.SubscriptionFeatures{
			AiChat:              plan.AiChatEnabled,
			SemanticSearch:      plan.SemanticSearchEnabled,
			MaxNotebooks:        plan.MaxNotebooks,
			MaxNotesPerNotebook: plan.MaxNotesPerNotebook,
		},
	}, nil
}

func (s *paymentService) CancelSubscription(ctx context.Context, userId uuid.UUID) error {
	// Look for active sub
	uow := s.uowFactory.NewUnitOfWork(ctx)
	subs, err := uow.SubscriptionRepository().FindAllSubscriptions(ctx, specification.UserOwnedBy{UserID: userId})
	if err != nil {
		return err
	}

	var activeSub *entity.UserSubscription
	for _, sub := range subs {
		if sub.Status == entity.SubscriptionStatusActive {
			activeSub = sub
			break
		}
	}

	if activeSub == nil {
		return errors.New("no active subscription found")
	}

	activeSub.Status = entity.SubscriptionStatusCanceled
	return uow.SubscriptionRepository().UpdateSubscription(ctx, activeSub)
}



>>> FILE: D:\notetaker\notefiber-BE\internal\repository\implementation\subscription_repository_impl.go
package implementation

import (
	"context"
	"errors"

	"ai-notetaking-be/internal/entity"
	"ai-notetaking-be/internal/mapper"
	"ai-notetaking-be/internal/model"
	"ai-notetaking-be/internal/repository/contract"
	"ai-notetaking-be/internal/repository/specification"

	"github.com/google/uuid"
	"gorm.io/gorm"
)

type SubscriptionRepositoryImpl struct {
	db     *gorm.DB
	mapper *mapper.SubscriptionMapper
}

func NewSubscriptionRepository(db *gorm.DB) contract.SubscriptionRepository {
	return &SubscriptionRepositoryImpl{
		db:     db,
		mapper: mapper.NewSubscriptionMapper(),
	}
}

func (r *SubscriptionRepositoryImpl) applySpecifications(db *gorm.DB, specs ...specification.Specification) *gorm.DB {
	for _, spec := range specs {
		db = spec.Apply(db)
	}
	return db
}

// Plan Implementation

func (r *SubscriptionRepositoryImpl) CreatePlan(ctx context.Context, plan *entity.SubscriptionPlan) error {
	m := r.mapper.PlanToModel(plan)
	if err := r.db.WithContext(ctx).Create(m).Error; err != nil {
		return err
	}
	*plan = *r.mapper.PlanToEntity(m)
	return nil
}

func (r *SubscriptionRepositoryImpl) UpdatePlan(ctx context.Context, plan *entity.SubscriptionPlan) error {
	m := r.mapper.PlanToModel(plan)
	if err := r.db.WithContext(ctx).Save(m).Error; err != nil {
		return err
	}
	*plan = *r.mapper.PlanToEntity(m)
	return nil
}

func (r *SubscriptionRepositoryImpl) DeletePlan(ctx context.Context, id uuid.UUID) error {
	return r.db.WithContext(ctx).Delete(&model.SubscriptionPlan{}, id).Error
}

func (r *SubscriptionRepositoryImpl) FindOnePlan(ctx context.Context, specs ...specification.Specification) (*entity.SubscriptionPlan, error) {
	var m model.SubscriptionPlan
	query := r.applySpecifications(r.db.WithContext(ctx), specs...)
	// Preload Features
	query = query.Preload("Features")
	if err := query.First(&m).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return r.mapper.PlanToEntity(&m), nil
}

func (r *SubscriptionRepositoryImpl) FindAllPlans(ctx context.Context, specs ...specification.Specification) ([]*entity.SubscriptionPlan, error) {
	var models []*model.SubscriptionPlan
	query := r.applySpecifications(r.db.WithContext(ctx), specs...)
	// Preload Features
	query = query.Preload("Features")
	if err := query.Find(&models).Error; err != nil {
		return nil, err
	}
	entities := make([]*entity.SubscriptionPlan, len(models))
	for i, m := range models {
		entities[i] = r.mapper.PlanToEntity(m)
	}
	return entities, nil
}

// Subscription Implementation

func (r *SubscriptionRepositoryImpl) CreateSubscription(ctx context.Context, subscription *entity.UserSubscription) error {
	m := r.mapper.UserSubscriptionToModel(subscription)
	if err := r.db.WithContext(ctx).Create(m).Error; err != nil {
		return err
	}
	*subscription = *r.mapper.UserSubscriptionToEntity(m)
	return nil
}

func (r *SubscriptionRepositoryImpl) UpdateSubscription(ctx context.Context, subscription *entity.UserSubscription) error {
	m := r.mapper.UserSubscriptionToModel(subscription)
	if err := r.db.WithContext(ctx).Save(m).Error; err != nil {
		return err
	}
	*subscription = *r.mapper.UserSubscriptionToEntity(m)
	return nil
}

func (r *SubscriptionRepositoryImpl) DeleteSubscription(ctx context.Context, id uuid.UUID) error {
	return r.db.WithContext(ctx).Delete(&model.UserSubscription{}, id).Error
}

func (r *SubscriptionRepositoryImpl) FindOneSubscription(ctx context.Context, specs ...specification.Specification) (*entity.UserSubscription, error) {
	var m model.UserSubscription
	query := r.applySpecifications(r.db.WithContext(ctx), specs...)
	if err := query.First(&m).Error; err != nil {
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, nil
		}
		return nil, err
	}
	return r.mapper.UserSubscriptionToEntity(&m), nil
}

func (r *SubscriptionRepositoryImpl) FindAllSubscriptions(ctx context.Context, specs ...specification.Specification) ([]*entity.UserSubscription, error) {
	var models []*model.UserSubscription
	query := r.applySpecifications(r.db.WithContext(ctx), specs...)
	if err := query.Find(&models).Error; err != nil {
		return nil, err
	}
	entities := make([]*entity.UserSubscription, len(models))
	for i, m := range models {
		entities[i] = r.mapper.UserSubscriptionToEntity(m)
	}
	return entities, nil
}

// Dashboard / Admin Stats implementation

func (r *SubscriptionRepositoryImpl) GetTotalRevenue(ctx context.Context) (float64, error) {
	var total float64
	// Sum of Plan.Price where subscription is PAID
	// Assuming "payment_status" = 'success' in user_subscriptions (as per entity constant)
	err := r.db.WithContext(ctx).Table("user_subscriptions").
		Joins("JOIN subscription_plans ON user_subscriptions.plan_id = subscription_plans.id").
		Where("user_subscriptions.payment_status = ?", "success").
		Select("COALESCE(SUM(subscription_plans.price), 0)").
		Scan(&total).Error
	return total, err
}

func (r *SubscriptionRepositoryImpl) CountActiveSubscribers(ctx context.Context) (int, error) {
	var count int64
	err := r.db.WithContext(ctx).Model(&model.UserSubscription{}).
		Where("status = ?", "active").
		Count(&count).Error
	return int(count), err
}

func (r *SubscriptionRepositoryImpl) GetTransactions(ctx context.Context, status string, limit, offset int) ([]*entity.SubscriptionTransaction, error) {
	var results []*entity.SubscriptionTransaction

	// Join UserSubscription, User, Plan
	query := r.db.WithContext(ctx).Table("user_subscriptions").
		Select(`
			user_subscriptions.id,
			user_subscriptions.user_id,
			users.email as user_email,
			subscription_plans.name as plan_name,
			subscription_plans.price as amount,
			user_subscriptions.status,
			user_subscriptions.payment_status,
			user_subscriptions.created_at,
			user_subscriptions.midtrans_transaction_id as midtrans_order_id
		`).
		Joins("JOIN users ON user_subscriptions.user_id = users.id").
		Joins("JOIN subscription_plans ON user_subscriptions.plan_id = subscription_plans.id")

	if status != "" {
		query = query.Where("user_subscriptions.payment_status = ?", status)
	}

	err := query.Order("user_subscriptions.created_at DESC").
		Limit(limit).
		Offset(offset).
		Scan(&results).Error

	if err != nil {
		return nil, err
	}

	return results, nil
}

// Feature Management Implementation

func (r *SubscriptionRepositoryImpl) AddFeatureToPlan(ctx context.Context, planId uuid.UUID, featureId uuid.UUID) error {
	// Use GORM Association to add many-to-many link
	plan := &model.SubscriptionPlan{Id: planId}
	feature := &model.Feature{Id: featureId}
	return r.db.WithContext(ctx).Model(plan).Association("Features").Append(feature)
}

func (r *SubscriptionRepositoryImpl) RemoveFeatureFromPlan(ctx context.Context, planId uuid.UUID, featureId uuid.UUID) error {
	// Use GORM Association to remove many-to-many link
	plan := &model.SubscriptionPlan{Id: planId}
	feature := &model.Feature{Id: featureId}
	return r.db.WithContext(ctx).Model(plan).Association("Features").Delete(feature)
}



>>> FILE: D:\notetaker\notefiber-BE\internal\repository\unitofwork\unit_of_work_impl.go
package unitofwork

import (
	"context"
	"fmt"

	"ai-notetaking-be/internal/repository/contract"
	"ai-notetaking-be/internal/repository/implementation"

	"gorm.io/gorm"
)

type UnitOfWorkImpl struct {
	db *gorm.DB
	tx *gorm.DB // The active transaction (or just db if no tx) - actually we should keep track if we are in tx
}

func NewUnitOfWork(db *gorm.DB) UnitOfWork {
	return &UnitOfWorkImpl{
		db: db,
	}
}

func (u *UnitOfWorkImpl) getDB() *gorm.DB {
	if u.tx != nil {
		return u.tx
	}
	return u.db
}

func (u *UnitOfWorkImpl) Begin(ctx context.Context) error {
	if u.tx != nil {
		return fmt.Errorf("transaction already started")
	}
	u.tx = u.db.WithContext(ctx).Begin()
	return u.tx.Error
}

func (u *UnitOfWorkImpl) Commit() error {
	if u.tx == nil {
		return fmt.Errorf("no transaction to commit")
	}
	err := u.tx.Commit().Error
	u.tx = nil
	return err
}

func (u *UnitOfWorkImpl) Rollback() error {
	if u.tx == nil {
		return fmt.Errorf("no transaction to rollback")
	}
	err := u.tx.Rollback().Error
	u.tx = nil
	return err
}

// Repository Accessors

func (u *UnitOfWorkImpl) UserRepository() contract.UserRepository {
	return implementation.NewUserRepository(u.getDB())
}

func (u *UnitOfWorkImpl) NotebookRepository() contract.NotebookRepository {
	return implementation.NewNotebookRepository(u.getDB())
}

func (u *UnitOfWorkImpl) NoteRepository() contract.NoteRepository {
	return implementation.NewNoteRepository(u.getDB())
}

func (u *UnitOfWorkImpl) NoteEmbeddingRepository() contract.NoteEmbeddingRepository {
	return implementation.NewNoteEmbeddingRepository(u.getDB())
}

func (u *UnitOfWorkImpl) ChatSessionRepository() contract.ChatSessionRepository {
	return implementation.NewChatSessionRepository(u.getDB())
}

func (u *UnitOfWorkImpl) ChatMessageRepository() contract.ChatMessageRepository {
	return implementation.NewChatMessageRepository(u.getDB())
}

func (u *UnitOfWorkImpl) ChatMessageRawRepository() contract.ChatMessageRawRepository {
	return implementation.NewChatMessageRawRepository(u.getDB())
}

func (u *UnitOfWorkImpl) SubscriptionRepository() contract.SubscriptionRepository {
	return implementation.NewSubscriptionRepository(u.getDB())
}

func (u *UnitOfWorkImpl) FeatureRepository() contract.FeatureRepository {
	return implementation.NewFeatureRepository(u.getDB())
}

func (u *UnitOfWorkImpl) BillingRepository() contract.BillingRepository {
	return implementation.NewBillingRepository(u.getDB())
}

func (u *UnitOfWorkImpl) RefundRepository() contract.RefundRepository {
	return implementation.NewRefundRepository(u.getDB())
}




